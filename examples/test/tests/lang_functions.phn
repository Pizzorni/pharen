;here test coverage of lang.phn


(check (when (== 1 1) (= x 2)) 2)

(check (not (== 2 2)) FALSE)

(check (pharen-or (== 3 1) (== 1 2)) FALSE)
(check (pharen-or (== 1 1) (== 1 2)) TRUE)

(check (pharen-and (== 1 1) (== 1 2)) FALSE)
(check (pharen-and (== 1 1) (== 2 2)) TRUE)

(check ((thunk (+ 1 2))) 3)


(class A  (access public (local name "")))
(local a (new A))
(check (inst? a #A) TRUE)


(check (first [0 1 2]) 0)
(check (rest [0 1 2]) [1 2])
(check (pharen-list 1 2 3) [1 2 3])
(check (last [1 2 3]) 3)
(check (butlast [1 2 3]) [1 2])
(check (eq 1 1) TRUE)
(check (eq 1 2) FALSE)
(local a1 (new A))
(check (eq a1 a1) TRUE)


(check (if-let [x 2] x FALSE) 2)
(check (when-let [x 2] x) 2)
(check (if-not (== 1 2) #a #b) #a)
(check (when-not (== 1 2) #a) #a)

(let [y 100]
  (dotimes [x 100] (= y (+ x y)) (check y (+ x 100)))) 
    
(check (zero? 0) TRUE)
(check (zero? 1) FALSE)

(check (pos? 1) TRUE)
(check (pos? -1) FALSE)

(check (neg? -1) TRUE)
(check (neg? 1) FALSE)

(check (odd? (/ 100 2)) FALSE)
(check (even? (/ 100 2)) TRUE)

(check (str "a" "b") "ab")
(check (identity 1) 1)
(check (inc 1) 2)
(check (dec 2) 1)

(let [fnx (comp (lambda (x) (+ 1 x) (lambda (y) (+ 2 y))))] (check (($fnx 1) 1) 3))

